## 假的头指针 dummyHead
```javascript
    const dummyHead = new ListNode(0);
    dummyHead.next = head;
    let temp = dummyHead;
```

- 链表的话，**递归**很好用！如果用递归，就不用考虑单向链表不能反过来传递的局限了。尤其是`需要建立多个指针去移动判断`的时候，递归不能再方便。
- `计算链表位置，要求返回某位置的节点的题`：使用**双指针**。1⃣️可以**先出发一个指针，k部之后再出发一个**，来计算，当前一个指针到达指定位置时，输出后一个的位置；2⃣️**快慢指针**，用来求链表中`环`的长度，一快一慢追击问题，相遇时的指针一定在环内，并且快指针速度是慢指针两倍速度的情况下，两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口（详见055题）
- `Python万物皆指针`，别把头指针带跑，想用的话只能 p = head.next 来引用并继续操作。以及如果这么做，要注意头指针首个状态的分类讨论。
- `万能方法`当然是`hash表`，把链表存起来之后随便查随便找，但是面试官肯定不希望只会这种偷鸡方法
- 整串链表全部是引用,不是可复制的实体，所以是无法做到直接复制一个新的链的，如果想要`clone`一个链表，想遍历却只能用它仅有的next属性，我们只能将每个节点的旁边插入一个相同的节点，全部扩充完再将它们拆分出来。